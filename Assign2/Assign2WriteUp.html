<!DOCTYPE html>
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
* {
    scrollbar-color: #454a4d #202324;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
<title>Assignment 2</title>
<link rel="stylesheet" href="Assign2WriteUp_files/styles241.css"><style class="darkreader darkreader--cors" media="screen">body {
   font-family: "Open Sans", Helvetica, sans-serif;
}

pre, code {
   font-family: "Courier New", Courier, monospace;
}

h1, h2, h3, h4 {
   font-family: "Lato", sans-serif;
   font-weight: 700;
}</style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="bdb0c4e8f72f0ebbfd68c6db5cb510b4"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1 {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
embed[type="application/pdf"] { filter: invert(100%) contrast(90%); }</style></head>

<body>
    
<h2 style="text-align:center">Assignment 2</h2>

<hr>

<p>In this assignment, you will write two short programs to solve problems using recursion.</p>

<h2>1. Initial Setup</h2>

<hr>

<ol>
    <li><p>Log in to Unix.</p></li>
    
    <li><p>Run the <code>setup</code> script for Assignment 2 by typing:</p>
        
<pre>    setup 2
</pre>
    </li>
</ol>

<p>The setup script will create the directory <code>Assign2</code> under your <code>csci241</code> directory. It will copy a <a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/makefiles.html">makefile</a> named <code>makefile</code> to the assignment directory and will also create <a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/Unix_Reference/command_ln.html">symbolic links</a> to a pair of test programs that you can use to verify that your output is correct.</p>

<p>Using the <code>makefile</code> we give you, you can build one specific program or build both programs. To build a single specific program, run the command <code>make</code> followed by the target name for the program that you want to build (<code>hanoi</code> or <code>queens</code>). For example:</p>

<pre>z123456@turing:~$ make hanoi</pre>

<p>To build both programs, run the command <code>make all</code> or just <code>make</code>.</p>

<p>Running the command <code>make clean</code> will remove all of the object and executable files created by the <code>make</code> command.</p>

<h2>2. Towers of Hanoi</h2>

<hr>

<p>Legend has it that in a temple in the Far East, priests are 
attempting to move a stack of disks from one peg to another. The initial
 stack had 64 disks threaded onto one peg and arranged from bottom to 
top by decreasing size. The priests are attempting to move the stack 
from this peg to a second peg under the constraints that exactly one 
disk is moved at a time, and at no time may a larger disk be placed 
above a smaller disk. A third peg is available for temporarily holding 
the disks. According to the legend, the world will end when the priests 
complete their task.</p>

<p>Consider three pegs numbered 1 through 3. Let us assume that the 
priests are attempting to move the 64 disks from peg 1 to peg 2, using 
peg 3 as a temporary holding peg. The problem is to design an algorithm 
that that will print the precise sequence of disk peg-to-peg transfers.</p>

<p>If you were to approach this problem with conventional methods, you 
would rapidly find yourself hopelessly knotted up in managing the disks.
 Instead, if you attack the problem with recursion in mind, it 
immediately becomes tractable. If we assume that we have a function that
 can move <em>n</em> - 1 disks from one peg to another using a third peg
 as a temporary holding peg, then we can easily formulate an algorithm 
to move <em>n</em> disks from peg 1 (the source peg) to peg 2 (the
destination peg) by using the function that moves <em>n</em> - 1 disks as follows:</p>

<ol>
<li><p>Move <em>n</em> - 1 disks from peg 1 (the source peg) to peg 3 
(the temporary holding peg), using peg 2 (the destination peg) as a 
temporary holding peg. This is a recursive call.</p></li>
<li><p>Move the last disk (the largest) from peg 1 (the source peg) to 
peg 2 (the destination peg). "Moving a disk" is accomplished simply by 
printing a line of output (see <strong>Output</strong> below for the format of the output line); nothing is actually moved.</p></li>
<li><p>Move the <em>n</em> - 1 disks from peg 3 (the temporary holding 
peg) to peg 2 (the destination peg), using peg 1 (the source peg) as a 
temporary holding peg. This is another recursive call.</p></li>
</ol>

<p>Write a <em>recursive</em> program that solves the Towers of Hanoi problem. Your solution must be recursive to be eligible for any credit.</p>

<h3>2.1. Input</h3>

<p>Your program must accept a <a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/command_line_arguments.html">single command line argument</a>, a positive integer. This integer <em>n</em> will represents the number of disks to move. Number the disks from 1 (the smallest disk) to <em>n</em>
 (the largest disk). You should always start with all the disks on peg 1
 with pegs 2 and 3 empty. Your program should then produce the sequence 
of disk peg-to-peg moves to move all the disks from peg 1 to peg 2.</p>

<h3>2.2. Output</h3>

<p>Your output should print one move per line. Each move must be in the following format,</p>

<pre>1 2-&gt;3</pre>

<p>which is interpreted as "move disk 1 from peg 2 to peg 3." Assuming that the name of your program is <code>hanoi</code>, below is an example of what an execution of your program should look like:</p>

<pre>z123456@turing:~$ ./hanoi 2
1 1-&gt;3
2 1-&gt;2
1 3-&gt;2
z123456@turing:~$</pre>

<p>The format of the output must be exactly has shown above. There is 
another program (described below) that we have written to check the 
output of your program. It expects exactly this format.</p>

<p><strong>WARNING:</strong> The number of moves it takes to transfer 
the disks from peg 1 to 2 grows exponentially as you increase the number
 of disks, (for <em>n</em> disks the number of moves is 2<sup><em>n</em> - 1</sup>).
 If each move produces 7 bytes of output, redirecting the 20 disk output
 to a file will produce a 7MB file. Take care not to do that. It is safe
 to run your program with as many disks as you want as long as the 
output goes to the screen. But be careful not to redirect the <code>stdout</code> of your program for large disk counts, e.g., do not do the following,

</p><pre>z123456@turing:~/csci241/Assign2$ ./hanoi 20 &gt; 20.out</pre>

<p>If this does happen, don't panic. Simply remove the file using the command</p>

<pre>rm 20.out</pre>

<h3>2.3. Files You Must Write</h3>

<p>Write the code for this part of the assignment in a single file which must be called <code>hanoi.cpp</code>.</p>

<h3>2.4. Files We Give You</h3>

<p>If you use the <code>setup</code> command to get ready for this assignment, you will find an executable file called <code>test_hanoi</code> in your <code>~/csci241/Assign2</code> directory.</p>

<p>You can use <code>test_hanoi</code> to test the output of your program (rather then checking it by hand). <code>test_hanoi</code> reads the output (in the format described above) of <code>hanoi</code> and prints either "SUCCESS" or "failure". <code>test_hanoi</code> also takes a command line argument that must match the command line argument passed to <code>hanoi</code> that generated the output file.</p>

<p>You can run <code>test_hanoi</code> in one of two ways.</p>

<pre>z123456@turing:~/csci241/Assign2$ ./hanoi 5 &gt; 5.out
z123456@turing:~/csci241/Assign2$ ./test_hanoi 5 &lt; 5.out
SUCCESS
z123456@turing:~/csci241/Assign2$
</pre>

<p>In this method you are storing the output from <code>hanoi</code> in a file called <code>5.out</code> and then passing that file to <code>test_hanoi</code>. This should only be used for smaller runs, say problems with 10 or fewer disks. You might want to run <code>hanoi</code> this way while debugging; in case <code>test_hanoi</code> reports "failure", you can hand-inspect <code>5.out</code> to find the error.</p>

<pre>z123456@turing:~/csci241/Assign2$ ./hanoi 5 | ./test_hanoi 5
SUCCESS
z123456@turing:~/csci241/Assign2$
</pre>

<p>In this method you do not create an output file. The output of <code>hanoi</code> is "piped" directly as input to <code>test_hanoi</code>.
 Running large problems (many disks) with this method does not create 
large files but may take very long to execute. You're probably safe with
 disk counts &lt; 20.</p>

<h3>2.5. Hints</h3>

<p>Consider writing a recursive function</p>

<pre>void move(int n_disks, int src_peg, int dest_peg, int temp_peg)</pre>

<p>You can call this function initially from <code>main()</code> and then call it recursively to perform Steps 1 and 3 of the algorithm outlined above.</p>

<p>Note that the peg numbers corresponding to the <code>src_peg</code>, <code>dest_peg</code>, and <code>temp_peg</code>
 will change with each recursive call, so the code you write for this 
function's body should use the variable names, not literal values like 
1, 2, and 3.</p> 

<h2>3. Eight Queens</h2>

<hr>

<p>Write a program that places eight queens on a chessboard (8 x 8 
board) such that no queen is "attacking" another. Queens in chess can 
move vertically, horizontally, or diagonally.</p>

<p>How you solve this problem is entirely up to you. You may choose to 
write a recursive program or an iterative (i.e., non-recursive) program.
 You will not be penalized/rewarded for choosing one method or another. 
Do what is easiest for you.</p>

<h3>3.1. Output</h3>

<p>Below is one solution to the eight queens problem, there may be 
others. Your program only needs to find one solution, any solution, and 
print it. Assuming the name of your program is <code>queens</code>, executing your program should look like this:</p>

<pre>z123456@turing:~/csci241/Assign2$ ./queens
1 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 1
0 0 0 0 0 1 0 0
0 0 1 0 0 0 0 0
0 0 0 0 0 0 1 0
0 1 0 0 0 0 0 0
0 0 0 1 0 0 0 0
z123456@turing:~/csci241/Assign2$
</pre>

<p>where a '1'; means a queen is on that square of the board and a '0' means the square is empty.</p>

<p>Note that it is very important that your output be formatted exactly 
as shown above. In grading your program, its output will be checked by 
another program (we wrote) that expects as input a solution in this 
format.</p>

<h3>3.2. Files You Must Write</h3>

<p>Write the code for this part of the assignment in a single file which must be called <code>queens.cpp</code>.</p>

<h3>3.3. Files We Give You</h3>

<p>If you use the <code>setup</code> command to get ready for this assignment, you will find an executable file called <code>test_queens</code> in your <code>~/csci241/Assign2</code> directory.</p>

<p>You can use <code>test_queens</code> to test the output of your program (rather then checking it by hand). <code>test_queens</code> reads the output (in the format described above) of <code>queens</code> and prints either "SUCCESS" or "failure".</p>

<p>You can run <code>test_queens</code> in one of two ways.</p>

<pre>z123456@turing:~/csci241/Assign2$ ./queens &gt; queens.out
z123456@turing:~/csci241/Assign2$ ./test_queens &lt; queens.out
SUCCESS
z123456@turing:~/csci241/Assign2$
</pre>

<p>In this method you are storing the output from <code>queens</code> in a file called <code>queens.out</code> and then passing that file to <code>test_queens</code>. You might want to run <code>queens</code> this way while debugging; in case <code>test_queens</code> reports "failure", you can hand-inspect <code>queens.out</code> to find the error.</p>

<pre>z123456@turing:~/csci241/Assign2$ ./queens | ./test_queens
SUCCESS
z123456@turing:~/csci241/Assign2$
</pre>

<p>In this method you do not create an output file. The output of <code>queens</code> is "piped" directly as input to <code>test_queens</code>.</p>

<h3>3.4. Hints</h3>

<p>You might want to represent the chessboard using a 2-D array of integers or Boolean variables, e.g., <code>int board[8][8]</code> or <code>bool board[8][8]</code>. This array can be declared in your <code>main()</code> function or as a data member of a class that you write. Initialize the board by filling the array with 0s or <code>false</code>.</p>

<p><img src="Assign2WriteUp_files/chessboard.jpg" alt="chess board" style="float:right; margin-left:50px" width="400" height="400">
A general strategy is to solve the problem by starting with the top row 
of the chessboard and proceeding down the chessboard one row at a time. <strong>Only place a single queen in each row</strong>.
 This eliminates the need to check for other queens on the same row 
(i.e., queens that could attack horizontally). Always start processing a
 row by attempting to place a queen in the leftmost column and then 
moving to the right as needed. When placing a queen in a particular row,
 remember that it suffices
to <strong>only check squares in the rows above you</strong>. For 
example, the red lines in the chess board image to the right illustrate 
the squares that must be checked for an existing queen when trying to 
place a new queen in the sixth column of the fourth row.</p> 

<p>If the queen is safe in a particular column, then place it on the board at that column (<code>board[row][col] = 1;</code> or <code>board[row][col] = true;</code>)
 and proceed to the next row. If it is not safe, then continue to move 
one column to the right until you find a safe spot or you run out of 
columns.</p>

<p>There are two general ways that you can solve the eight queens 
problem: recursively or iteratively. Below are some more general hints 
that use the suggestions above, first in a recursive algorithm and then 
in an iterative algorithm. Although two general algorithms are discussed
 below, remember that you are only required to write one solution to 
this problem. Write as many solutions as you would like, but submit only
 one program for grading. You may elect to use the hints from either 
section below, or you may decide to ignore all of them and design a 
solution on your own. Whatever you decide is acceptable.</p>

<h4>3.3.1. Recursive Algorithm</h4>

<p>You could write a recursive function called <code>place_queens()</code>
 that returns a Boolean value and accepts two arguments, the chessboard 
and a row index. If your chessboard is a data member of a class, then 
this will be a member function of that class and you will only need to 
pass it the row index.</p>

<p>The way to think about <code>place_queens()</code> is that it 
attempts to place a queen in the row that you specified and all rows 
below that. If it can place all of the queens from that row down, it 
returns <code>true</code> and leaves the queens on the chessboard. If it couldn't, then it returns <code>false</code>
 and removes all the queens from that row down. This way, after you 
initialize the chessboard, you may make a single call from your <code>main()</code> routine like this</p>

<pre>place_queens(board, 0);     // Call a function</pre>

<p>or this</p>

<pre>q.place_queens(0);          // Call a member function</pre>

<p>(assuming that <code>q</code> is an instance of the class that you defined).</p>

<p>In either case, you need to check the return value of the function for success or failure.</p>

<p><code>place_queens()</code> always starts by attempting to place a 
queen in the leftmost column of the row that it received as an argument 
and checking that it is safe from all the queens in the rows above it. 
If it is not safe, then proceed by moving the queen one column to the 
right and checking that square. If you get to the right end of the board
 without finding a safe spot, then return <code>false</code>. If you find a safe spot, then place the queen on the board and call <code>place_queens()</code>
 again (recursively) asking it to place all the queens on the rows below
 yours (i.e., passing it the same board it received but incrementing the
 row index by 1).</p>

<p>Test the return value of that recursive call. Recall that <code>place_queens()</code> will attempt to place all the queens in the rows below and return either <code>false</code> or <code>true</code> based on its success. If the return value is <code>true</code>, then simply return <code>true</code> yourself and you are done. If it is <code>false</code>,
 then there was no way to place the other queens on the board. You must 
try and find another safe column (to the right) in the same row. Move 
the queen in this row to the right, one column at a time, until you find
 another square where the queen is safe from all of the queens above it.
 If you find another safe column, place the queen there and make another
 recursive call to <code>place_queens()</code>. If there are no more safe columns in this row, then remove the queen from this row and return <code>false</code>.</p>

<p>The stopping condition for this recursive algorithm is when you enter <code>place_queens()</code> and the row that you have been passed in is greater than 7 (assuming that the top row is row 0).</p>

<h4>3.3.2. Iterative Algorithm</h4>

<p>Start by placing a queen in the leftmost column of the top row. Since
 there are no rows above the top row, there are no "attacking" queens to
 check, so proceed to the second row. As you move from the first row to 
the second row, we call this "approaching a row from the top". This is 
differs from "approaching a row from the bottom" (described below).</p>

<p>When approaching a row from the top, there are no queens on that row.
 Start by attempting to place the queen in the leftmost column and 
checking all of the rows above. If the queen is safe in that column, 
place it on the board and proceed to the next row. If it is not safe, 
try the next column to the right and check there. If you get to the end 
of the row without finding a safe column for the queen, you must back up
 a row. This requires you to go back to the previous row and move that 
queen to the right. This is what is meant by "approaching the row from 
the bottom".</p>

<p>When approaching a row from the bottom, there is already a queen 
placed on that row and it is already safe from all of the queens above 
it. The problem is that no more queens could be placed on the board in 
the rows below it. So this queen must be moved from its safe spot to 
another safe spot in the same row. All of the columns to the left of 
this queen have already been checked. The only place for this queen to 
go is to the right. Start by trying one square to the right and checking
 the rows above. If that column is safe, place the queen there and 
proceed to the row below, approaching it from the top. If it is not 
safe, keep moving the queen to the right. If you run out of columns, 
then remove the queen from the board and back up to the row above, 
approaching it from the bottom.</p>



</body></html>